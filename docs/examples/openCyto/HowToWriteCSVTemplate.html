---
title: "How to write a csv gating template"
output: 
  html_document: 
    number_sections: yes
    toc: yes
    toc_float: yes
    collapsed: no
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{How to write a csv gating template}
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<div id="how-to-write-a-csv-gating-template" class="section level1">
<h1>How to write a csv gating template</h1>
<p>The <strong>openCyto</strong> package is uses a spreadsheet to compose the gating schemes. Basically each row corresponds to one population node
in the gating hierarchy tree. However sometime it is verbose to describe every single population.
So here we will explain how to make the template more succinct to easier to compose by using <code>pop</code> and <code>alias</code> pattern.</p>
<div id="pop--" class="section level2">
<h2><code>pop</code> = “+/-”</h2>
<p>For the 1d/2d gating function, we are normally interested in either positive(representing cell events within gate) or negative(or negated, representing cell events outside of the gate) by setting <code>pop</code> column
in the form of <code>+</code> or <code>-</code>. But sometime we want to do the downstream gating for both.
By specifying <code>pop</code> as <code>+/-</code>, the <code>template parser</code> will expand it into two rows internally.</p>
<p>For example, this row will be expanded automatically</p>
<table>
<thead>
<tr class="header">
<th align="left">alias</th>
<th align="left">pop</th>
<th align="left">parent</th>
<th align="left">dims</th>
<th align="left">gating_method</th>
<th align="left">gating_args</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">*</td>
<td align="left">+/-</td>
<td align="left">cd3</td>
<td align="left">cd4</td>
<td align="left">mindensity</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>to two rows:</p>
<table>
<thead>
<tr class="header">
<th align="left">alias</th>
<th align="left">pop</th>
<th align="left">parent</th>
<th align="left">dims</th>
<th align="left">gating_method</th>
<th align="left">gating_args</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">cd4+</td>
<td align="left">+</td>
<td align="left">cd3</td>
<td align="left">cd4</td>
<td align="left">mindensity</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">cd4-</td>
<td align="left">-</td>
<td align="left">cd3</td>
<td align="left">cd4</td>
<td align="left">refGate</td>
<td align="left">cd3/cd4+</td>
</tr>
</tbody>
</table>
<p>Note that the second row uses <code>refGate</code> which simply copies the gate coordinates computed by <code>mindensity</code> in the first row,
and assign the negative sign to the <code>pop</code> column indicating the population of interest is <code>cd4 negative</code>.</p>
</div>
<div id="pop" class="section level2">
<h2><code>pop</code> = “++”</h2>
<p>Often time we need to apply 1d gating function on two dimensions separately and then
use the two cutting points to construct <code>rectangleGate</code> to capture the cell events falling into one particular quadrant on the 2-d projections
For example, <code>T helper</code> cells are usually represented as <code>CD4+CD8-</code>.
Instead of writing three rows in the template, simply using <code>++</code> pattern in the <code>pop</code> column.<br />
e.g</p>
<table>
<thead>
<tr class="header">
<th align="left">alias</th>
<th align="left">pop</th>
<th align="left">parent</th>
<th align="left">dims</th>
<th align="left">gating_method</th>
<th align="left">gating_args</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">T helper</td>
<td align="left">+-</td>
<td align="left">cd3</td>
<td align="left">cd4,cd8</td>
<td align="left">mindensity</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>And the template parser will take care of the expansion automatically.</p>
<table>
<thead>
<tr class="header">
<th align="left">alias</th>
<th align="left">pop</th>
<th align="left">parent</th>
<th align="left">dims</th>
<th align="left">gating_method</th>
<th align="left">gating_args</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">cd4+</td>
<td align="left">+</td>
<td align="left">cd3</td>
<td align="left">cd4</td>
<td align="left">mindensity</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">cd8+</td>
<td align="left">+</td>
<td align="left">cd3</td>
<td align="left">cd8</td>
<td align="left">mindensity</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">T helper</td>
<td align="left">+-</td>
<td align="left">cd3</td>
<td align="left">cd4,cd8</td>
<td align="left">refGate</td>
<td align="left">cd3/cd4+:cd3/cd8+</td>
</tr>
</tbody>
</table>
<p>As we see, first two rows do the actual gating by <code>mindensity</code> and the third row simply makes use the coordinates of that two 1d gates (<code>cd4+</code> and <code>cd8+</code>) and
construct a <code>rectangleGate</code> (T helper) by using <code>refGate</code> as <code>gating_method</code>. And the <code>+</code> and <code>-</code> sign along with dimensions determines which quadrant to keep.</p>
</div>
<div id="pop---" class="section level2">
<h2><code>pop</code> = “+/-+/-”</h2>
<p>Apparently, we may want to get more than one quadrants by using the same mechanism.
For example, we can set <code>pop</code> to <code>+/-+/-</code> to keep all of four quadrants.</p>
<table>
<thead>
<tr class="header">
<th align="left">alias</th>
<th align="left">pop</th>
<th align="left">parent</th>
<th align="left">dims</th>
<th align="left">gating_method</th>
<th align="left">gating_args</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">*</td>
<td align="left">+/-+/-</td>
<td align="left">cd3</td>
<td align="left">cd4,cd8</td>
<td align="left">mindensity</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>It will be expanded to six rows:</p>
<table>
<thead>
<tr class="header">
<th align="left">alias</th>
<th align="left">pop</th>
<th align="left">parent</th>
<th align="left">dims</th>
<th align="left">gating_method</th>
<th align="left">gating_args</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">cd4+</td>
<td align="left">+</td>
<td align="left">cd3</td>
<td align="left">cd4</td>
<td align="left">mindensity</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">cd8+</td>
<td align="left">+</td>
<td align="left">cd3</td>
<td align="left">cd8</td>
<td align="left">mindensity</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">cd4+cd8+</td>
<td align="left">++</td>
<td align="left">cd3</td>
<td align="left">cd4,cd8</td>
<td align="left">refGate</td>
<td align="left">cd3/cd4+:cd3/cd8+</td>
</tr>
<tr class="even">
<td align="left">cd4-cd8+</td>
<td align="left">-+</td>
<td align="left">cd3</td>
<td align="left">cd4,cd8</td>
<td align="left">refGate</td>
<td align="left">cd3/cd4+:cd3/cd8+</td>
</tr>
<tr class="odd">
<td align="left">cd4+cd8-</td>
<td align="left">+-</td>
<td align="left">cd3</td>
<td align="left">cd4,cd8</td>
<td align="left">refGate</td>
<td align="left">cd3/cd4+:cd3/cd8+</td>
</tr>
<tr class="even">
<td align="left">cd4-cd8-</td>
<td align="left">–</td>
<td align="left">cd3</td>
<td align="left">cd4,cd8</td>
<td align="left">refGate</td>
<td align="left">cd3/cd4+:cd3/cd8+</td>
</tr>
</tbody>
</table>
<p>First two does the actual gating, and rest of four uses two 1d gates to construct four different <code>rectangleGate</code>s to represent
four different quadrants.</p>
</div>
<div id="gating-method-that-generates-multiple-populations" class="section level2">
<h2>Gating method that generates multiple populations</h2>
<div id="pop-and-alias-abc" class="section level3">
<h3><code>pop</code> = "*" and <code>alias</code> = “A,B,C”</h3>
<p>So far, we’ve been talking about the gating functions that only returns one gate object( <code>S4 class</code> that extends <code>flowCore::filter</code>).
If we want to apply the gating function(e.g. <code>curv2filter</code> or <code>flowClust::tmixFilter</code>) that returns more than one gates,
we can set <code>pop</code> to <code>*</code> and specify multiple population names within <code>alias</code> with comma-separated characters.</p>
<table>
<thead>
<tr class="header">
<th align="left">alias</th>
<th align="left">pop</th>
<th align="left">parent</th>
<th align="left">dims</th>
<th align="left">gating_method</th>
<th align="left">gating_args</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">CD4,CD8</td>
<td align="left">*</td>
<td align="left">cd3</td>
<td align="left">cd4,cd8</td>
<td align="left">curv2gate</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Here we assume <code>curv1gate</code> always returns <code>two</code> gates in the order of <code>c("cd4", "cd8")</code>, then the population names in <code>alias</code> column
will be matched to these two gates and two <code>dummy_gate</code> rows are generated that simply serves as a reference to be used<br />
as <code>parent</code> node of the downstream gates.</p>
<table>
<thead>
<tr class="header">
<th align="left">alias</th>
<th align="left">pop</th>
<th align="left">parent</th>
<th align="left">dims</th>
<th align="left">gating_method</th>
<th align="left">gating_args</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">CD4,CD8</td>
<td align="left">*</td>
<td align="left">cd3</td>
<td align="left">cd4,cd8</td>
<td align="left">curv2gate</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">CD4</td>
<td align="left"></td>
<td align="left">cd3</td>
<td align="left">cd4,cd8</td>
<td align="left">dummy_gate</td>
<td align="left">cd3/CD4,CD8</td>
</tr>
<tr class="odd">
<td align="left">CD8</td>
<td align="left"></td>
<td align="left">cd3</td>
<td align="left">cd4,cd8</td>
<td align="left">dummy_gate</td>
<td align="left">cd3/CD4,CD8</td>
</tr>
</tbody>
</table>
</div>
<div id="pop-and-alias" class="section level3">
<h3><code>pop</code> = “<em>" and <code>alias</code> = "</em>”</h3>
<p>If we don’t know how many gates will be returned by <code>curv2gate</code> or the order of gates are undetermined, thus we will not able to
name these populations. As long as they are not used as <code>parent</code> nodes for the further gating (i.e. <code>terminal gate</code>s), we can
simply set <code>alias</code> to <code>*</code> .</p>
<table>
<thead>
<tr class="header">
<th align="left">alias</th>
<th align="left">pop</th>
<th align="left">parent</th>
<th align="left">dims</th>
<th align="left">gating_method</th>
<th align="left">gating_args</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">*</td>
<td align="left">*</td>
<td align="left">cd3</td>
<td align="left">cd4,cd8</td>
<td align="left">curv2gate</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>This will not be expanded in the <code>openCyto</code> framework. However, multiple populations will be generated and added
to the <code>GatingSet</code> object. They are named by the <code>filterId</code> slot of <code>filter</code> objects.</p>
</div>
</div>
<div id="single-row-with-multiple-parents-i.e.-parent-abc" class="section level2">
<h2>Single row with multiple parents (i.e. <code>parent</code> =“A,B,C”)</h2>
<p>If the same gating method (or simply <code>refGate</code>) needs to be applied to multiple parents, it is possible to write these into the single row. For example,</p>
<table>
<thead>
<tr class="header">
<th align="left">alias</th>
<th align="left">pop</th>
<th align="left">parent</th>
<th align="left">dims</th>
<th align="left">gating_method</th>
<th align="left">gating_args</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">IL2+</td>
<td align="left">+</td>
<td align="left">cd4,cd8</td>
<td align="left">IL2</td>
<td align="left">refGate</td>
<td align="left">cd3/IL2+</td>
</tr>
</tbody>
</table>
<p>This row is interpreted as copying the <code>IL2</code> gate that has been generated from <code>cd3</code> population and applying it to <code>cd4</code> and <code>cd8</code>, which is equivalent to the rows of below</p>
<table>
<thead>
<tr class="header">
<th align="left">alias</th>
<th align="left">pop</th>
<th align="left">parent</th>
<th align="left">dims</th>
<th align="left">gating_method</th>
<th align="left">gating_args</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">IL2+</td>
<td align="left">+</td>
<td align="left">cd4</td>
<td align="left">IL2</td>
<td align="left">refGate</td>
<td align="left">cd3/IL2+</td>
</tr>
<tr class="even">
<td align="left">IL2+</td>
<td align="left">+</td>
<td align="left">cd8</td>
<td align="left">IL2</td>
<td align="left">refGate</td>
<td align="left">cd3/IL2+</td>
</tr>
</tbody>
</table>
</div>
</div>
