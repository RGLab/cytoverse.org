---
title: "An Introduction to the openCyto package"
output: 
  html_document: 
    number_sections: no
    toc: yes
    toc_float: yes
    collapsed: no
vignette: >
  %\VignetteEngine{knitr}
  %\VignetteIndexEntry{An Introduction to the openCyto package}
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<pre><code>## Loading required package: flowWorkspaceData</code></pre>
<div id="introduction" class="section level2">
<h2>1. Introduction</h2>
<p>The <strong>openCyto</strong> package is designed to facilitate the application of automated gating methods in a sequential way to mimic the construction of a manual gating scheme.</p>
<div id="manual-gating" class="section level3">
<h3>1.1. Manual gating</h3>
<p>Traditionally, scientists have to draw the gates for each individual sample on each 2-D projection (2 channels) within <code>flowJo</code>. Alternatively, they can draw template gates on one sample and replicate them to other samples, then manually inspect the gate on each sample
to do the correction if necessary. Either way is time consuming and subjective, thus not suitable for the large data sets
generated by high-throughput flow cytometry, CyTOF, or “cross-lab” data analysis.</p>
<p>Here is one <code>xml</code> workspace (manual gating scheme) exported from <code>flowJo</code>.</p>
<pre class="r"><code>flowDataPath &lt;- system.file(&quot;extdata&quot;, package = &quot;flowWorkspaceData&quot;)
wsfile &lt;- list.files(flowDataPath, pattern=&quot;manual.xml&quot;,full = TRUE)
wsfile</code></pre>
<pre><code>## [1] &quot;/usr/local/lib/R/cytoset/flowWorkspaceData/extdata/manual.xml&quot;</code></pre>
<p>By using the <code>CytoML</code> package, We can load it into R,</p>
<pre class="r"><code>library(CytoML)
ws &lt;- open_flowjo_xml(wsfile)</code></pre>
<p>apply the<code>manual gates</code>defined in<code>xml</code>to the raw<code>FSC</code>files,</p>
<pre class="r"><code>gs &lt;- flowjo_to_gatingset(ws, name= &quot;T-cell&quot;, subset =1, isNcdf = TRUE)</code></pre>
<p>and then visualize the<code>Gating Hierarchy</code></p>
<pre class="r"><code>gh &lt;- gs[[1]]
plot(gh)</code></pre>
<p><img src="docs/examples/openCyto/openCytoVignette_files/figure-html/plot-manual-GatingHierarchy-1.png" width="672" style="display:block; margin: auto" style="display: block; margin: auto;" />
and the<code>gates</code>:</p>
<pre class="r"><code>library(ggcyto)
autoplot(gh)</code></pre>
<p><img src="docs/examples/openCyto/openCytoVignette_files/figure-html/plot-manual-gates-1.png" width="864" style="display:block; margin: auto" style="display: block; margin: auto;" />
This is a gating scheme for a <code>T cell</code> panel, which tries to identify <code>T cell</code> sub-populations.
We can achieve the same results by using the automated gating pipeline provided by this package.</p>
</div>
<div id="automated-gating" class="section level3">
<h3>1.2. Automated Gating</h3>
<p><code>flowCore</code>,<code>flowStats</code>,<code>flowClust</code> and other packages provide many different gating methods to
detect cell populations and draw gates automatically.</p>
<p>The <code>flowWorkspace</code> package provides the <code>GatingSet</code> as an efficient data structure to store, query and visualize the hierarchical gated data.</p>
<p>By taking advantage of these tools, the <code>openCyto</code> package can create the automated gating pipeline by a <code>gatingTemplate</code>, which is essentially the same kind of hierarchical gating scheme
used by scientists.</p>
</div>
</div>
<div id="create-gating-templates" class="section level2">
<h2>2. Create gating templates</h2>
<div id="template-format" class="section level3">
<h3>2.1. Template format</h3>
<p>First of all, we need to describe the gating hierarchy in a spread sheet (a plain text format).
This spread sheet must have the following columns:</p>
<ul>
<li><code>alias</code>: a name used to label the cell population, with the path composed of the alias and its precedent nodes (e.g. /root/A/B/alias) being uniquely identifiable.</li>
<li><code>pop</code>: population patterns of <code>+/-</code> or <code>+/-+/-</code>, which tell the algorithm which side (postive or negative) of a 1-D gate or which quadrant of a 2-D gate are to be kept.</li>
<li><code>parent</code>: the parent population alias, whose path also has to be uniquely identifiable.</li>
<li><code>dims</code>: characters seperated by commas specifying the dimensions (1-D or 2-D) used for gating. These can be either channel names or stained marker names.</li>
<li><code>gating_method</code>: the name of the gating function (e.g. <code>flowClust</code>). It is invoked by a wrapper function that has the identical function name prefixed with a dot.(e.g. <code>.flowClust</code>)</li>
<li><code>gating_args</code>: the named arguments passed to the gating function</li>
<li><code>collapseDataForGating</code>: When TRUE, data is collapsed (within groups if <code>groupBy</code> is specified) before gating and the gate is replicated across collapsed samples.
When set FALSE (or blank), the <code>groupBy</code> argument is only used by <code>preprocessing</code> and ignored by gating.</li>
<li><code>groupBy</code>: If provided, samples are split into groups by the unique combinations of the named study variable (i.e. column names of pData, e.g.“PTID:VISITNO”).
When this is numeric (N), samples are grouped by every N samples</li>
<li><code>preprocessing_method</code>: the name of the preprocessing function (e.g. <code>prior_flowClust</code>). It is invoked by a wrapper function that has the identical function name prefixed with a dot (e.g. <code>.prior_flowClust</code>).
The preprocessing results are then passed to the appropriate gating wrapper function through its <code>pps_res</code> argument.</li>
<li><code>preprocessing_args</code>: the named arguments passed to the preprocessing function.</li>
</ul>
</div>
<div id="example-template" class="section level3">
<h3>2.2. Example template</h3>
<p>Here is an example of a gating template.</p>
<pre class="r"><code>library(openCyto)
library(data.table)
gtFile &lt;- system.file(&quot;extdata/gating_template/tcell.csv&quot;, package = &quot;openCyto&quot;)
dtTemplate &lt;- fread(gtFile)
dtTemplate</code></pre>
<pre><code>##             alias    pop    parent        dims   gating_method
##  1:     nonDebris      +      root       FSC-A gate_mindensity
##  2:      singlets      + nonDebris FSC-A,FSC-H     singletGate
##  3:         lymph      +  singlets FSC-A,SSC-A       flowClust
##  4:           cd3      +     lymph         CD3 gate_mindensity
##  5:             * -/++/-       cd3     cd4,cd8 gate_mindensity
##  6: activated cd4     ++  cd4+cd8-    CD38,HLA        tailgate
##  7: activated cd8     ++  cd4-cd8+    CD38,HLA        tailgate
##  8:      CD45_neg      -  cd4+cd8-      CD45RA gate_mindensity
##  9:     CCR7_gate      +  CD45_neg        CCR7       flowClust
## 10:             * +/-+/-  cd4+cd8- CCR7,CD45RA         refGate
## 11:             * +/-+/-  cd4-cd8+ CCR7,CD45RA gate_mindensity
##               gating_args collapseDataForGating groupBy preprocessing_method
##  1:                                          NA      NA                     
##  2:                                          NA      NA                     
##  3: K=2,target=c(1e5,5e4)                    NA      NA      prior_flowClust
##  4:                                        TRUE       4                     
##  5:     gate_range=c(1,3)                    NA      NA                     
##  6:                                          NA      NA  standardize_flowset
##  7:              tol=0.08                    NA      NA  standardize_flowset
##  8:     gate_range=c(2,3)                    NA      NA                     
##  9:           neg=1,pos=1                    NA      NA                     
## 10:    CD45_neg:CCR7_gate                    NA      NA                     
## 11:                                          NA      NA                     
##     preprocessing_args
##  1:                 NA
##  2:                 NA
##  3:                 NA
##  4:                 NA
##  5:                 NA
##  6:                 NA
##  7:                 NA
##  8:                 NA
##  9:                 NA
## 10:                 NA
## 11:                 NA</code></pre>
<p>Each row is usually corresponding to one cell population and the gating method that is used to get that population.
We will try to explain how to create this gating template based on the manual gating scheme row by row.</p>
<div id="nondebris" class="section level4">
<h4>2.2.1. “nonDebris”</h4>
<pre class="r"><code>dtTemplate[1,]</code></pre>
<pre><code>##        alias pop parent  dims   gating_method gating_args collapseDataForGating
## 1: nonDebris   +   root FSC-A gate_mindensity                                NA
##    groupBy preprocessing_method preprocessing_args
## 1:      NA                                      NA</code></pre>
<ul>
<li>The population name is <code>"nonDebris"</code> (specified in the <code>alias</code> field).</li>
<li>The <code>parent</code> node is <code>root</code> (which is always the first node of a <code>GatingHierarchy</code> by default).</li>
<li>We use <code>mindensity</code> (one of the <code>gating</code> functions provided by <code>openCyto</code> package) as the <code>gating_method</code> to gate on dimension (<code>dim</code>) of <code>FSC-A</code>.</li>
<li>As a result, it will generate a 1-D gate on <code>FSC-A</code>. The <code>+</code> in the <code>pop</code> field indicates the
<code>positive</code> side of the 1-D gate is kept as the population of interest.</li>
<li>There is no <code>grouping</code> or <code>preprocessing</code> involved in this gate, so the other columns are left blank.</li>
</ul>
</div>
<div id="singlets" class="section level4">
<h4>2.2.2. “singlets”</h4>
<pre class="r"><code>dtTemplate[2,]</code></pre>
<pre><code>##       alias pop    parent        dims gating_method gating_args
## 1: singlets   + nonDebris FSC-A,FSC-H   singletGate            
##    collapseDataForGating groupBy preprocessing_method preprocessing_args
## 1:                    NA      NA                                      NA</code></pre>
<ul>
<li>The population name is <code>"singlets"</code> (the <code>alias</code> field).</li>
<li>The <code>parent</code> node is <code>nonDebris</code>.</li>
<li>The <code>gating_method</code> is <code>singletGate</code> (a function from the <code>flowStats</code> package)</li>
<li>As a result, a <code>polygonGate</code> will be generated on <code>FSC-A</code> and <code>FSC-H</code> (specified by <code>dims</code>) for each sample.</li>
<li>Again, the <code>+</code> in the <code>pop</code> field stands for <code>"singlets+"</code>. But here it is 2-D gate, which means we want to keep the area
inside of the polygon.</li>
</ul>
</div>
<div id="lymphocytes" class="section level4">
<h4>2.2.3. “lymphocytes”</h4>
<pre class="r"><code>dtTemplate[3,]</code></pre>
<pre><code>##    alias pop   parent        dims gating_method           gating_args
## 1: lymph   + singlets FSC-A,SSC-A     flowClust K=2,target=c(1e5,5e4)
##    collapseDataForGating groupBy preprocessing_method preprocessing_args
## 1:                    NA      NA      prior_flowClust                 NA</code></pre>
<ul>
<li>Similarly, <code>alias</code> specifies the name of population.</li>
<li><code>parent</code> points to <code>singlets</code></li>
<li>Since we are going to use <code>flowClust</code> as <code>gating_method</code> to do the 2-dimensional gating,
<code>dims</code> is a comma-separated string: <code>x</code> axis (<code>FSC-A</code>) goes first, <code>y</code> (<code>SSC-A</code>) the second.
This order doesn’t affect the gating process but will determine how the gates are displayed.<br />
</li>
<li>All the parameters that <code>flowClust</code> algorithm accepts can be put in <code>gating_args</code> as if they are typed in the <code>R console</code>.
see <code>help(flowClust)</code> for more details of these arguments</li>
<li>The <code>flowClust</code> algorithm accepts the extra argument <code>prior</code> that is calculated during the <code>preprocessing</code> stage (before the actual gating). Thus, we supply the <code>preprocessing_method</code> with <code>prior_flowClust</code>.</li>
</ul>
</div>
<div id="cd3-tcells" class="section level4">
<h4>2.2.4. “cd3+” (Tcells)</h4>
<pre class="r"><code>dtTemplate[4,]</code></pre>
<pre><code>##    alias pop parent dims   gating_method gating_args collapseDataForGating
## 1:   cd3   +  lymph  CD3 gate_mindensity                              TRUE
##    groupBy preprocessing_method preprocessing_args
## 1:       4                                      NA</code></pre>
<p>This is similar to the <code>nonDebris</code> gate except that we specify <code>collapseDataForGating</code> as <code>TRUE</code>,
which tells the pipeline to <code>collapse</code> all samples into one and apply <code>mindensity</code> to the collapsed data on <code>CD3</code> dimension.
Once the gate is generated, it is replicated across all samples. This is only useful when each individual sample does not have
enough events to deduce the gate. Here we do this just for the purpose of proof of concept.</p>
</div>
<div id="cd4-and-cd8" class="section level4">
<h4>2.2.5. CD4 and CD8</h4>
<p>The fifth row specifies <code>pop</code> as <code>cd4+/-cd8+/-</code>, which will be expanded into 6 rows.</p>
<pre class="r"><code>dtTemplate[5,]</code></pre>
<pre><code>##    alias    pop parent    dims   gating_method       gating_args
## 1:     * -/++/-    cd3 cd4,cd8 gate_mindensity gate_range=c(1,3)
##    collapseDataForGating groupBy preprocessing_method preprocessing_args
## 1:                    NA      NA                                      NA</code></pre>
<p>The first two rows are two 1-D gates that will be generated by <code>gating_method</code> on each
dimension (<code>cd4</code> and <code>cd8</code>) independently:</p>
<pre><code>##    alias pop                        parent dims   gating_method
## 1:  cd4+   + /nonDebris/singlets/lymph/cd3  cd4 gate_mindensity
## 2:  cd8+   + /nonDebris/singlets/lymph/cd3  cd8 gate_mindensity
##          gating_args collapseDataForGating groupBy preprocessing_method
## 1: gate_range=c(1,3)                                                   
## 2: gate_range=c(1,3)                                                   
##    preprocessing_args
## 1:                   
## 2:</code></pre>
<p>Then another 4 rows are 4 <code>rectangleGate</code>s that corresponds to the 4 <code>quadrants</code> in the 2-D projection (<code>cd4 vs cd8</code>).</p>
<pre><code>##       alias pop                        parent    dims gating_method
## 1: cd4+cd8+  ++ /nonDebris/singlets/lymph/cd3 cd4,cd8       refGate
## 2: cd4-cd8+  -+ /nonDebris/singlets/lymph/cd3 cd4,cd8       refGate
## 3: cd4+cd8-  +- /nonDebris/singlets/lymph/cd3 cd4,cd8       refGate
## 4: cd4-cd8-  -- /nonDebris/singlets/lymph/cd3 cd4,cd8       refGate
##                                                              gating_args
## 1: /nonDebris/singlets/lymph/cd3/cd4+:/nonDebris/singlets/lymph/cd3/cd8+
## 2: /nonDebris/singlets/lymph/cd3/cd4+:/nonDebris/singlets/lymph/cd3/cd8+
## 3: /nonDebris/singlets/lymph/cd3/cd4+:/nonDebris/singlets/lymph/cd3/cd8+
## 4: /nonDebris/singlets/lymph/cd3/cd4+:/nonDebris/singlets/lymph/cd3/cd8+
##    collapseDataForGating groupBy preprocessing_method preprocessing_args
## 1:                                                                      
## 2:                                                                      
## 3:                                                                      
## 4:</code></pre>
<p>As we see here, <code>"refGate"</code> in <code>gating_method</code> indicates that they are constructed based on the
<code>gate coordinates</code> of the previous two 1-D gates.
Those 1-D gates are thus considered as “reference gates” that are referred to by a colon-separated <code>alias</code> string in <code>gating_args</code>: <code>"cd4+:cd8+"</code>.</p>
<p>Alternatively, we can expand it into these 6 rows explicitly in the spreadsheet.
But this convenient representation is recommended unless the user wants to have finer control on how the gating is done.
For instance, sometimes we need to use different <code>gating_method</code>s to generate 1-D gates on <code>cd4</code> and <code>cd8</code>.
Or it could be the case that <code>cd8</code> gating needs to depend on <code>cd4</code> gating, i.e. the <code>parent</code> of <code>cd8+</code> is <code>cd4+</code>(or <code>cd4-</code>) instead of <code>cd3</code>.
Sometimes we want to have a customized <code>alias</code> other than the quadrant-like name (<code>x+y+</code>) that gets generated automatically.
(e.g. 5th row of the gating template)</p>
</div>
</div>
</div>
<div id="load-gating-template" class="section level2">
<h2>3. Load gating template</h2>
<p>After the gating template is defined in the spreadsheet, it can be loaded into R:</p>
<pre class="r"><code>gt_tcell &lt;- gatingTemplate(gtFile)
gt_tcell</code></pre>
<pre><code>## --- Gating Template: default
##  with  29  populations defined</code></pre>
<p>Besides looking at the spreadsheet, we can examine the gating scheme by visualizing it:</p>
<pre class="r"><code>plot(gt_tcell)</code></pre>
<p><img src="docs/examples/openCyto/openCytoVignette_files/figure-html/plot-gt-1.png" width="672" style="display:block; margin: auto" style="display: block; margin: auto;" />
As we can see, the gating scheme has been expanded as we described above.
All the <strong>colored</strong> arrows source from a <code>parent</code> population and the <strong>grey</strong> arrows source from a <code>reference</code> population(/gate).</p>
</div>
<div id="run-the-gating-pipeline" class="section level2">
<h2>4. Run the gating pipeline</h2>
<p>Once we are satisfied with the gating template, we can apply it to the actual flow data.</p>
<div id="load-the-raw-data" class="section level3">
<h3>4.1. Load the raw data</h3>
<p>First of all, we load the raw FCS files into R by <code>ncdfFlow::read.ncdfFlowSet</code> (it uses less memory than <code>flowCore::read.flowSet</code>) and create an empty <code>GatingSet</code> object.</p>
<pre class="r"><code>fcsFiles &lt;- list.files(pattern = &quot;CytoTrol&quot;, flowDataPath, full = TRUE)
cs  &lt;- load_cytoset_from_fcs(fcsFiles)
cf &lt;- realize_view(cs[[1]])
gs &lt;- GatingSet(cs)
gs</code></pre>
<pre><code>## A GatingSet with 2 samples</code></pre>
</div>
<div id="compensation" class="section level3">
<h3>4.2. Compensation</h3>
<p>Then, we compensate the data. If we have compensation controls (i.e. singly stained samples), we can calculate the
compensation matrix by using the <code>flowStats::spillover</code> function.
Here we simply use the compensation matrix defined in the <code>flowJo</code> workspace.</p>
<pre class="r"><code>compMat &lt;- gh_get_compensations(gh)
compensate(gs, compMat)</code></pre>
<pre><code>## A GatingSet with 2 samples</code></pre>
<p>Here is one example showing the compensation outcome:</p>
<pre><code>## A cytoset with 2 samples.
## 
##   column names:
##     V545-A, V450-A
## 
## cytoset has been subsetted and can be realized through &#39;realize_view()&#39;.</code></pre>
<p><img src="docs/examples/openCyto/openCytoVignette_files/figure-html/compensate_plot-1.png" width="384" style="display:block; margin: auto" style="display: block; margin: auto;" /></p>
</div>
<div id="transformation" class="section level3">
<h3>4.3. Transformation</h3>
<p>All of the stained channels need to be transformed properly before the gating.
Here we use the <code>flowCore::estimateLogicle</code> method to determine the <code>logicle</code> transformation.</p>
<pre class="r"><code>chnls &lt;- parameters(compMat)
trans &lt;- estimateLogicle(gs[[1]], channels = chnls)
gs &lt;- transform(gs, trans)</code></pre>
<p>Here is one example showing the transformation outcome:
<img src="docs/examples/openCyto/openCytoVignette_files/figure-html/transformation_plot-1.png" width="480" style="display:block; margin: auto" style="display: block; margin: auto;" /></p>
</div>
<div id="gating" class="section level3">
<h3>4.5. Gating</h3>
<p>Now we can apply the gating template to the data:</p>
<pre class="r"><code>gt_gating(gt_tcell, gs)</code></pre>
<p>Optionally, we can run the pipeline in parallel to speed up gating. e.g.</p>
<pre class="r"><code>gt_gating(gt_tcell, gs, mc.cores=2, parallel_type = &quot;multicore&quot;)</code></pre>
</div>
<div id="hide-nodes" class="section level3">
<h3>4.6. Hide nodes</h3>
<p>After gating, there are some extra populations generated automatically by the pipeline (e.g. <code>refGate</code>).</p>
<pre class="r"><code>plot(gs[[1]])</code></pre>
<p><img src="docs/examples/openCyto/openCytoVignette_files/figure-html/plot_afterGating-1.png" width="672" style="display:block; margin: auto" style="display: block; margin: auto;" />
We can hide these populations if we are not interested in them:</p>
<pre class="r"><code>nodesToHide &lt;- c(&quot;cd8+&quot;, &quot;cd4+&quot;
                , &quot;cd4-cd8-&quot;, &quot;cd4+cd8+&quot;
                , &quot;cd4+cd8-/HLA+&quot;, &quot;cd4+cd8-/CD38+&quot;
                , &quot;cd4-cd8+/HLA+&quot;, &quot;cd4-cd8+/CD38+&quot;
                , &quot;CD45_neg/CCR7_gate&quot;, &quot;cd4+cd8-/CD45_neg&quot;
                , &quot;cd4-cd8+/CCR7+&quot;, &quot;cd4-cd8+/CD45RA+&quot;
                )
lapply(nodesToHide, function(thisNode) gs_pop_set_visibility(gs, thisNode, FALSE))</code></pre>
</div>
<div id="rename-nodes" class="section level3">
<h3>4.7. Rename nodes</h3>
<p>And rename the populations:</p>
<pre class="r"><code>gs_pop_set_name(gs, &quot;cd4+cd8-&quot;, &quot;cd4&quot;)
gs_pop_set_name(gs, &quot;cd4-cd8+&quot;, &quot;cd8&quot;)</code></pre>
<pre class="r"><code>plot(gs[[1]])</code></pre>
<p><img src="docs/examples/openCyto/openCytoVignette_files/figure-html/plot_afterHiding-1.png" width="672" style="display:block; margin: auto" style="display: block; margin: auto;" /></p>
</div>
<div id="visualize-the-gates" class="section level3">
<h3>4.8. Visualize the gates</h3>
<pre class="r"><code>autoplot(gs[[1]])</code></pre>
<p><img src="docs/examples/openCyto/openCytoVignette_files/figure-html/plotGate_autoGate-1.png" width="864" style="display:block; margin: auto" style="display: block; margin: auto;" /></p>
</div>
<div id="apply-a-gating-method-without-csv-template" class="section level3">
<h3>4.9. Apply a gating method without csv template</h3>
<p>Sometimes it will be helpful (especially when working with data that is already gated) to be able to interact with the <code>GatingSet</code> directly without the need to write the complete csv gating template. We can apply each automated gating method using the same fields as in the <code>gatingTemplate</code>, but provided as arguments to the <code>gs_add_gating_method</code> function. The populations added by each of these calls to <code>gs_add_gating_method</code> can be removed sequentially by <code>gs_remove_gating_method</code>, which will remove <em>all</em> populations added by the prior call to <code>gs_add_gating_method</code>. These two functions allow for interactive stagewise prototyping of a <code>gatingTemplate</code>.</p>
<p>For example, suppose we wanted to add a <code>CD38-/HLA-</code> sub-population to the <code>cd4+cd8-</code> population. We could do this as follows:</p>
<pre class="r"><code>gs_add_gating_method(gs, alias = &quot;non-activated cd4&quot;,
                         pop = &quot;--&quot;,
                         parent = &quot;cd4&quot;,
                         dims = &quot;CD38,HLA&quot;,
                         gating_method = &quot;tailgate&quot;)
plot(gs[[1]])</code></pre>
<p><img src="docs/examples/openCyto/openCytoVignette_files/figure-html/gt_add_gating_method-1.png" width="672" style="display:block; margin: auto" style="display: block; margin: auto;" /></p>
<p>The addition of this population can then easily be undone by a call to <code>gs_remove_gating_method</code>:</p>
<pre class="r"><code>gs_remove_gating_method(gs)
plot(gs[[1]])</code></pre>
<p><img src="docs/examples/openCyto/openCytoVignette_files/figure-html/gs_remove_gating_method-1.png" width="672" style="display:block; margin: auto" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="conclusion" class="section level2">
<h2>5. Conclusion</h2>
<p>The <code>openCyto</code> package allows users to specify their gating schemes and gate the data
in a data-driven fashion. It frees the scientists from the labor-intensitive manual gating routines
and increases the speed as well as the reproducibilty and objectivity of the data analysis work.</p>
</div>
