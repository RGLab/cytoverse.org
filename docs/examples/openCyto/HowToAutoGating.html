---
title: "OpenCyto: How to use different auto gating functions"
author: "Mike Jiang"
output: 
  html_document: 
    keep_md: yes
    toc: yes
    toc_float: yes
vignette: >    
  %\VignetteIndexEntry{How to use different auto gating functions}    
  %\VignetteEngine{knitr::rmarkdown}
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>Here we will illustrate how to choose and use the appropriate gating methods that are pre-registered in <code>openCyto</code> package. And users can always define their own <code>gating</code> algorithms and register them as the <code>plugin</code> functions in <code>openCyto</code> framework, see <code>?registerPlugins</code> for more details.</p>
<p>Note that all the function names illustrated below are prefixed with <code>.</code> indicating that they are simply the wrapper function registered in <code>openCyto</code>. The actual <code>gating engine</code> behind the wrapper can come from other packages (e.g. <code>flowCore</code>, <code>flowClust</code>).
All these wrappers have these common interfaces:
* <code>fr</code>: a <code>flowFrame</code> object
* <code>pp_res</code>: an optional <code>pre-preocessing</code> result, which can be ignored in this document
* <code>channels</code>: channel names used for gating
* <code>...</code>: any other gating parameters pass on to the actual gating engine</p>
<pre class="r"><code>library(flowCore)
library(flowWorkspace)
library(openCyto)
library(ggcyto)

gs &lt;- load_gs(system.file(&quot;extdata/gs_bcell_auto&quot;, package = &quot;flowWorkspaceData&quot;))</code></pre>
<div id="d-gating-methods" class="section level2">
<h2>1D gating methods</h2>
<div id="mindensity" class="section level3">
<h3><code>mindensity</code></h3>
<p>The name of this gating function is self-explaining, that is to find the minimum as the cutpoint between negative and postive peaks in 1d density plot. It is fast,robust and extremely easy to use especially when there is a good separation between <code>+</code> and <code>-</code> populations/peaks.</p>
<p>For example, it is usually easy to gate on <code>CD3</code> channel and no need to supply any arguments to the method.</p>
<pre class="r"><code>fr &lt;- gh_pop_get_data(gs[[2]], &quot;Live&quot;)
chnl &lt;- &quot;CD3&quot;
g &lt;- openCyto:::.mindensity(fr, channels = chnl)
autoplot(fr, chnl) + geom_gate(g)
autoplot(fr, chnl, &quot;SSC-A&quot;) + geom_gate(g)</code></pre>
<p><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-3-1.png" width="288" /><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-3-2.png" width="288" /></p>
<p>However, it may need some guidance when there are more than <code>2</code> major peaks/populations detected in densit profile.</p>
<pre class="r"><code>fr &lt;- gh_pop_get_data(gs[[1]], &quot;boundary&quot;)
chnl &lt;- &quot;FSC-A&quot;
g &lt;- openCyto:::.mindensity(fr, channels = chnl)
mylimits &lt;- ggcyto_par_set(limits = &quot;instrument&quot;)
p &lt;- autoplot(fr, chnl) + mylimits
p + geom_gate(g)
autoplot(fr, chnl, &quot;SSC-A&quot;) + geom_gate(g)</code></pre>
<p><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-4-1.png" width="288" /><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-4-2.png" width="288" /></p>
<p>Here we actually want to remove the <code>debris cells</code> that are represented by the first negative peak. But <code>mindensity</code> cuts between the second and third peaks since they are more predorminant. So we can simply specify a <code>range</code> that will limit the locations where the cut point should be placed.</p>
<pre class="r"><code>g &lt;- openCyto:::.mindensity(fr, channels = chnl, gate_range=c(7e4,1e5), adjust = 1.5)
p + geom_gate(g)
autoplot(fr, chnl, &quot;SSC-A&quot;) + geom_gate(g)</code></pre>
<p><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-5-1.png" width="288" /><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-5-2.png" width="288" /></p>
<p>And as shown, we also changed the <code>kernal density</code> smoothing factor <code>adjust</code> from <code>2</code>(default value set in <code>openCtyo</code>) to <code>1.5</code> to avoid over-smoothing.</p>
<p>Alternatively you can achieve the same effect by setting <code>min</code> or <code>max</code> to pre-filter the data before the <code>mindenstiy</code> works on it.</p>
<pre class="r"><code>g &lt;- openCyto:::.mindensity(fr, channels = chnl, min = 7e4, max = 1e5)
p + geom_gate(g)</code></pre>
<p><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-6-1.png" width="288" /></p>
<p>To choose one way or the other or combining both is highly dependent on how your data. The more contrains will give you more controls on how gating proceeds yet at cost of robustness of your gating pipeline sometime.</p>
</div>
<div id="tailgate" class="section level3">
<h3><code>tailgate</code></h3>
<p>This gating method is used in the senarios where there is only one major peak detected thus automatically disqualify the usage of <code>mindensity</code>. <code>tol</code> is to control how far the cut point should be placed away from the peak.</p>
<pre class="r"><code>fr &lt;- gh_pop_get_data(gs[[1]], &quot;lymph&quot;)
chnl &lt;- &quot;Live&quot;
g &lt;- openCyto:::.tailgate(fr, channels = chnl, tol = 0.05)
p &lt;- autoplot(fr, chnl) + mylimits
p + geom_gate(g)
autoplot(fr, chnl, &quot;SSC-A&quot;) + geom_gate(g)</code></pre>
<p><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-7-1.png" width="288" /><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-7-2.png" width="288" /></p>
</div>
<div id="quantilegate" class="section level3">
<h3><code>quantileGate</code></h3>
<p>This method is an alternative to <code>tailgate</code> and it determines the cutpoint by the events quantile.</p>
<pre class="r"><code>g &lt;- openCyto:::.quantileGate(fr, channels = chnl, probs = 0.99)
p &lt;- autoplot(fr, chnl) + mylimits
p + geom_gate(g)
autoplot(fr, chnl, &quot;SSC-A&quot;) + geom_gate(g)</code></pre>
<p><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-8-1.png" width="288" /><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-8-2.png" width="288" /></p>
<p>This gating method is more commonly used in gating the <code>rare</code> populations when the target population is not prominent enough to stand out as the second peak. (e.g. <code>cytokine</code> gates in <code>ICS</code> assays.)</p>
</div>
</div>
<div id="d-gating-methods-1" class="section level2">
<h2>2D gating methods</h2>
<div id="boundary-gate" class="section level3">
<h3><code>boundary Gate</code></h3>
<p>It essentially constructs a rectangle gate from input range (min, max), which is useful for filtering out very extreme signals at the bounary.</p>
<pre class="r"><code>fr &lt;- gh_pop_get_data(gs[[1]], &quot;root&quot;)
chnl &lt;- c(&quot;FSC-A&quot;, &quot;SSC-A&quot;)
g &lt;- openCyto:::.boundary(fr, channels = chnl, min = c(0, 0), max=c(2.5e5,2.5e5))
p &lt;- autoplot(fr, x = chnl[1], y = chnl[2])
p + geom_gate(g)</code></pre>
<p><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-9-1.png" width="288" /></p>
</div>
<div id="singletgate" class="section level3">
<h3><code>singletGate</code></h3>
<p>Use the <code>area</code> vs <code>height</code> to gate out the singlets. See details from <code>?singletGate</code>.</p>
<pre class="r"><code>fr &lt;- read.FCS(system.file(&quot;extdata/CytoTrol_CytoTrol_1.fcs&quot;, package = &quot;flowWorkspaceData&quot;))
chnl &lt;- c(&quot;FSC-A&quot;, &quot;FSC-H&quot;)
g &lt;- openCyto:::.singletGate(fr, channels = chnl)
p &lt;- autoplot(fr, x = chnl[1], y = chnl[2])
p + geom_gate(g)</code></pre>
<p><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-10-1.png" width="288" /></p>
</div>
<div id="flowclust.2d" class="section level3">
<h3><code>flowClust.2d</code></h3>
<p><code>flowClust</code> package in itself is not limited to 2-dimensional gating. But here we are talking about a dedicated wrapper function <code>.flowClust.2d</code> from <code>openCyto</code> package that leverages <code>flowClust</code> clustering engine to work on <code>2D</code> cases specifically. You won’t need to write the full name of the function in <code>csv</code> gating template, simply put <code>flowClust</code> in the <code>gating_method</code> column, and then the template parser will automatically dispatch to the right function.</p>
<pre class="r"><code>fr &lt;- gh_pop_get_data(gs[[1]], &quot;nonDebris&quot;)
chnl &lt;- c(&quot;FSC-A&quot;, &quot;SSC-A&quot;)
g &lt;- openCyto:::.flowClust.2d(fr, channels = chnl, K=2, target=c(1e5,5e4), quantile=0.95)
p &lt;- autoplot(fr, x = chnl[1], y = chnl[2]) + mylimits
p + geom_gate(g)</code></pre>
<p><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-11-1.png" width="288" /></p>
<p><code>K</code> is to tell the algorithm how many major clusters/populations are expected in the 2d profile. <code>target</code> specify the mean/center of the target population to get, which doesn’t have to be precise. If not supplied, flowClust will pick the most prominent cluster as the target, which would be the right choice in most cases.
<code>quantile</code> specify how large the <code>ellipse</code> should be. <code>pp_res</code> is used to provide the <code>prior</code> information for <code>flowClust</code>. (More details are in <code>?flowClust</code>)</p>
</div>
<div id="transitional-gate" class="section level3">
<h3><code>Transitional gate</code></h3>
<p><code>flowClust.2d</code> can optionally construct a <code>Transitional gate</code>, which is a speical kind of polygon gate with one edge placed diagonally that is often seen in <code>flowJo</code>. Here is an example:</p>
<pre class="r"><code>fr &lt;- gh_pop_get_data(gs[[1]], &quot;CD19andCD20&quot;)
chnl &lt;- c(&quot;CD38&quot;, &quot;CD24&quot;)
g &lt;- openCyto:::.flowClust.2d(fr, channels = chnl, K=6,transitional=TRUE,target=c(3.5e3,3.5e3), quantile=0.95,translation=0.15, pp_res = NULL)
p &lt;- autoplot(fr, x = chnl[1], y = chnl[2]) + mylimits
p + geom_gate(g)</code></pre>
<p><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-12-1.png" width="288" /></p>
<p>The rational behind the algorithm is beyond the scope of this document. Please see its detailed explainations in <code>?flowClust.2d</code>.</p>
</div>
<div id="quadgate.tmix" class="section level3">
<h3><code>quadGate.tmix</code></h3>
<p>This gating method identifies two quadrants (first, and third quadrants) by fitting the data with tmixture model.
It is particually useful when the two markers are not well resolved thus the regular quadGate method
that is based on <code>1d</code> gating will not find the perfect cut points on both dimensions.</p>
<pre class="r"><code>gs &lt;- load_gs(system.file(&quot;extdata/gs_DC_auto&quot;, package = &quot;flowWorkspaceData&quot;))
fr &lt;- gh_pop_get_data(gs[[2]], &quot;HLADR+&quot;)
chnl &lt;- c(&quot;CD11c&quot;, &quot;CD123&quot;)
p &lt;- autoplot(fr, chnl[1], chnl[2])
g &lt;- openCyto:::.quadGate.tmix(fr, channels = chnl, K = 3, usePrior = &quot;no&quot;)
p + geom_gate(g)</code></pre>
<p><img src="docs/examples/openCyto/HowToAutoGating_files/figure-html/unnamed-chunk-13-1.png" width="288" /></p>
</div>
</div>
