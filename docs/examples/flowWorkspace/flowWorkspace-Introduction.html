---
title: "flowWorkspace Introduction: A Package to store and maninpulate gated flow data"
output:
  html_document:
    number_sections: yes
    theme: united
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
author: Greg Finak <gfinak@fhcrc.org>, Mike Jiang <wjiang2@fhcrc.org>
vignette: >    
  %\VignetteKeywords{flow cytometry, single cell assay, import}
  %\VignettePackage{flowWorkspace}  
  %\VignetteIndexEntry{flowWorkspace Introduction: A Package to store and maninpulate gated flow data}
  %\VignetteEngine{knitr::rmarkdown}
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<div id="purpose" class="section level2">
<h2>Purpose</h2>
<p>The purpose of this package is to provide the infrastructure to store, represent and exchange gated flow data. By this we mean accessing the samples, groups, transformations, compensation matrices, gates, and population statistics in the gating tree, which is represented as a <code>GatingSet</code> object in <code>R</code>.</p>
<p>There are several ways to generate a <code>GatingSet</code>:
* built from scratch within <code>R</code> (which will be demonstrated later)
* imported from the XML workspace files exported from other software (e.g. FlowJo, Diva, CytoBank). Details on the importing xml are documented in <a href="https://www.bioconductor.org/packages/release/bioc/html/CytoML.html">CytoML</a> package.
* generated by automated gating framework from <a href="https://www.bioconductor.org/packages/release/bioc/html/openCyto.html">openCyto</a> package
* loaded from the existing GatingSet archive (that was previously saved by <code>save_gs()</code> call)</p>
<p>Here we simply load an example <code>GatingSet</code> archive to illustrate how to interact with a <code>GatingSet</code> object.</p>
<pre class="r"><code>library(flowWorkspace)
dataDir &lt;- system.file(&quot;extdata&quot;,package=&quot;flowWorkspaceData&quot;)
gs_archive &lt;- list.files(dataDir, pattern = &quot;gs_bcell_auto&quot;,full = TRUE)
gs &lt;- load_gs(gs_archive)
gs</code></pre>
<pre><code>## A GatingSet with 2 samples</code></pre>
<p>We have loaded a <code>GatingSet</code> with 2 samples, each of which has 14 associated gates.</p>
<p>To list the samples stored in <code>GatingSet</code>:</p>
<pre class="r"><code>sampleNames(gs)</code></pre>
<pre><code>## [1] &quot;12828_1_Bcell_C01.fcs&quot; &quot;12828_2_Bcell_C02.fcs&quot;</code></pre>
</div>
<div id="basics-on-gatingset" class="section level2">
<h2>Basics on GatingSet</h2>
<p>Subsets of a <code>GatingSet</code> can be accessed using the standard R subset syntax <code>[</code>.</p>
<pre class="r"><code>gs[1]</code></pre>
<pre><code>## A GatingSet with 1 samples</code></pre>
<p>We can plot the gating tree:</p>
<pre class="r"><code>plot(gs, bool = TRUE)</code></pre>
<p><img src="docs/examples/flowWorkspace/flowWorkspace-Introduction_files/figure-html/plotTree-1.png" width="672" />
The boolean gates(notes) are highlighted in blue color.</p>
<p>We can list the nodes (populations) in the gating hierarchy:</p>
<pre class="r"><code>gs_get_pop_paths(gs, path = 2)</code></pre>
<pre><code>##  [1] &quot;root&quot;                      &quot;boundary/nonDebris&quot;       
##  [3] &quot;nonDebris/lymph&quot;           &quot;lymph/Live&quot;               
##  [5] &quot;Live/CD20&quot;                 &quot;Live/CD19&quot;                
##  [7] &quot;Live/CD19andCD20&quot;          &quot;CD19andCD20/IgD-CD27-&quot;    
##  [9] &quot;CD19andCD20/IgD+CD27-&quot;     &quot;CD19andCD20/IgD-CD27+&quot;    
## [11] &quot;CD19andCD20/IgD+CD27+&quot;     &quot;CD19andCD20/Transitional&quot; 
## [13] &quot;Live/CD19and!CD20&quot;         &quot;CD19and!CD20/Plasmablasts&quot;
## [15] &quot;Live/CD3&quot;</code></pre>
<p>Note that the <code>path</code> argument specifies the depth of the gating path for each population.
As shown, <code>depth</code> of <code>1</code> (i.e. leaf or terminal node name) may not be sufficient to uniquely identify each population. The issue can be resolved by increasing the <code>path</code> or simply returning the full path of the node:</p>
<pre class="r"><code>gs_get_pop_paths(gs, path = &quot;full&quot;)</code></pre>
<pre><code>##  [1] &quot;root&quot;                                                    
##  [2] &quot;/boundary/nonDebris&quot;                                     
##  [3] &quot;/boundary/nonDebris/lymph&quot;                               
##  [4] &quot;/boundary/nonDebris/lymph/Live&quot;                          
##  [5] &quot;/boundary/nonDebris/lymph/Live/CD20&quot;                     
##  [6] &quot;/boundary/nonDebris/lymph/Live/CD19&quot;                     
##  [7] &quot;/boundary/nonDebris/lymph/Live/CD19andCD20&quot;              
##  [8] &quot;/boundary/nonDebris/lymph/Live/CD19andCD20/IgD-CD27-&quot;    
##  [9] &quot;/boundary/nonDebris/lymph/Live/CD19andCD20/IgD+CD27-&quot;    
## [10] &quot;/boundary/nonDebris/lymph/Live/CD19andCD20/IgD-CD27+&quot;    
## [11] &quot;/boundary/nonDebris/lymph/Live/CD19andCD20/IgD+CD27+&quot;    
## [12] &quot;/boundary/nonDebris/lymph/Live/CD19andCD20/Transitional&quot; 
## [13] &quot;/boundary/nonDebris/lymph/Live/CD19and!CD20&quot;             
## [14] &quot;/boundary/nonDebris/lymph/Live/CD19and!CD20/Plasmablasts&quot;
## [15] &quot;/boundary/nonDebris/lymph/Live/CD3&quot;</code></pre>
<p>But <code>full</code> path may not be necessary and could be too long to be visualized. So we provide the <code>path = 'auto'</code> option to determine the shortest path that is still unique within the gating tree.</p>
<pre class="r"><code>nodelist &lt;- gs_get_pop_paths(gs, path = &quot;auto&quot;)
nodelist</code></pre>
<pre><code>##  [1] &quot;root&quot;         &quot;nonDebris&quot;    &quot;lymph&quot;        &quot;Live&quot;         &quot;CD20&quot;        
##  [6] &quot;CD19&quot;         &quot;CD19andCD20&quot;  &quot;IgD-CD27-&quot;    &quot;IgD+CD27-&quot;    &quot;IgD-CD27+&quot;   
## [11] &quot;IgD+CD27+&quot;    &quot;Transitional&quot; &quot;CD19and!CD20&quot; &quot;Plasmablasts&quot; &quot;CD3&quot;</code></pre>
<p>We can get the gate associated with the specific population:</p>
<pre class="r"><code>node &lt;- nodelist[3]
g &lt;- gs_pop_get_gate(gs, node)
g</code></pre>
<pre><code>## $`12828_1_Bcell_C01.fcs`
## Ellipsoid gate &#39;lymph&#39; in dimensions FSC-A and SSC-A
## 
## $`12828_2_Bcell_C02.fcs`
## Ellipsoid gate &#39;lymph&#39; in dimensions FSC-A and SSC-A</code></pre>
<p>We can retrieve the population statistics :</p>
<pre class="r"><code>gs_pop_get_stats(gs)[1:10,]</code></pre>
<pre><code>##                    sample                                                  pop
##  1: 12828_1_Bcell_C01.fcs                                                 root
##  2: 12828_1_Bcell_C01.fcs                                  /boundary/nonDebris
##  3: 12828_1_Bcell_C01.fcs                            /boundary/nonDebris/lymph
##  4: 12828_1_Bcell_C01.fcs                       /boundary/nonDebris/lymph/Live
##  5: 12828_1_Bcell_C01.fcs                  /boundary/nonDebris/lymph/Live/CD20
##  6: 12828_1_Bcell_C01.fcs                  /boundary/nonDebris/lymph/Live/CD19
##  7: 12828_1_Bcell_C01.fcs           /boundary/nonDebris/lymph/Live/CD19andCD20
##  8: 12828_1_Bcell_C01.fcs /boundary/nonDebris/lymph/Live/CD19andCD20/IgD-CD27-
##  9: 12828_1_Bcell_C01.fcs /boundary/nonDebris/lymph/Live/CD19andCD20/IgD+CD27-
## 10: 12828_1_Bcell_C01.fcs /boundary/nonDebris/lymph/Live/CD19andCD20/IgD-CD27+
##     count
##  1: 81638
##  2: 80711
##  3: 52927
##  4: 51652
##  5: 11093
##  6: 11126
##  7: 11028
##  8:   765
##  9:  9219
## 10:   590</code></pre>
<p>We can plot individual gates. Note the scale of the transformed axes.
The second argument is the node path of any depth as long as it is uniquely identifiable.</p>
<pre class="r"><code>library(ggcyto)</code></pre>
<pre><code>## Warning: replacing previous import &#39;data.table:::=&#39; by &#39;ggplot2:::=&#39; when
## loading &#39;ggcyto&#39;</code></pre>
<pre class="r"><code>autoplot(gs, node)</code></pre>
<p><img src="docs/examples/flowWorkspace/flowWorkspace-Introduction_files/figure-html/autoplot-nodeName-1.png" width="672" />
More details about gate visualization can be found <a href="http://bioconductor.org/packages/release/bioc/html/ggcyto.html">here</a>.</p>
<p>If we have metadata associated with the experiment, it can be attached to the <code>GatingSet</code>.</p>
<pre class="r"><code>d &lt;- data.frame(sample=factor(c(&quot;sample 1&quot;, &quot;sample 2&quot;)),treatment=factor(c(&quot;sample&quot;,&quot;control&quot;)) )
pd &lt;- pData(gs)
pd &lt;- cbind(pd,d)
pData(gs) &lt;- pd
pData(gs)</code></pre>
<pre><code>##                         sample                  name treatment Center Replicate
## 12828_1_Bcell_C01.fcs sample 1 12828_1_Bcell_C01.fcs    sample  NHLBI         1
## 12828_2_Bcell_C02.fcs sample 2 12828_2_Bcell_C02.fcs   control  NHLBI         2
##                       Sample
## 12828_1_Bcell_C01.fcs  12828
## 12828_2_Bcell_C02.fcs  12828</code></pre>
<p>We can subset the <code>GatingSet</code> by its <code>pData</code> directly:</p>
<pre class="r"><code>subset(gs, treatment == &quot;control&quot;)</code></pre>
<pre><code>## A GatingSet with 1 samples</code></pre>
<p>The underlying <code>flow data</code> can be retrieved by:</p>
<pre class="r"><code>cs &lt;- gs_pop_get_data(gs)
class(cs)</code></pre>
<pre><code>## [1] &quot;cytoset&quot;
## attr(,&quot;package&quot;)
## [1] &quot;flowWorkspace&quot;</code></pre>
<pre class="r"><code>nrow(cs[[1]])</code></pre>
<pre><code>## [1] 81638</code></pre>
<p>Because <code>GatingSet</code> is a purely reference class, the class type returned by <code>gs_pop_get_data</code> is a <code>cytoset</code>, which is the purely reference class analog of a <code>flowSet</code> and will be discussed in more detail below. Also note that the data is already compensated and transformed during the parsing.</p>
<p>We can retrieve the subset of data associated with a population node:</p>
<pre class="r"><code>cs &lt;- gs_pop_get_data(gs, node)
nrow(cs[[1]])</code></pre>
<pre><code>## [1] 52927</code></pre>
</div>
<div id="gatinghierarchy" class="section level2">
<h2>GatingHierarchy</h2>
<p>We can retrieve a single gating hierarchical tree (corresponding to one sample) by using the <code>[[</code> extraction operator</p>
<pre class="r"><code>gh &lt;- gs[[1]]
gh</code></pre>
<pre><code>## Sample:  12828_1_Bcell_C01.fcs 
## GatingHierarchy with  15  gates</code></pre>
<p>Note that the index can be either numeric or character (the <code>guid</code> returned by the <code>sampleNames</code> method)</p>
<p>The <code>autoplot</code> method without specifying any node will lay out all the gates in the same plot</p>
<pre class="r"><code>autoplot(gh)</code></pre>
<p><img src="docs/examples/flowWorkspace/flowWorkspace-Introduction_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>We can retrieve the indices specifying if an event is included inside or outside a gate using:</p>
<pre class="r"><code>table(gh_pop_get_indices(gh,node))</code></pre>
<pre><code>## 
## FALSE  TRUE 
## 28711 52927</code></pre>
<p>The indices returned are relative to the parent population (member of parent AND member of current gate), so they reflect the true hierarchical gating structure.</p>
</div>
<div id="build-the-gatingset-from-scratch" class="section level2">
<h2>Build the GatingSet from scratch</h2>
<p><code>GatingSet</code> provides methods to build a gating tree from raw FCS files and add or remove flowCore gates (or populations) to or from it.</p>
<p>We start from a <code>flowSet</code> that contains three ungated flow samples:</p>
<pre class="r"><code>library(flowCore)
data(GvHD)
#select raw flow data
fs &lt;- GvHD[1:2]</code></pre>
<p>Then construct a <code>GatingSet</code> from the <code>flowSet</code>:</p>
<pre class="r"><code>gs &lt;- GatingSet(fs)</code></pre>
<p>Then compensate it:</p>
<pre class="r"><code>cfile &lt;- system.file(&quot;extdata&quot;,&quot;compdata&quot;,&quot;compmatrix&quot;, package=&quot;flowCore&quot;)
comp.mat &lt;- read.table(cfile, header=TRUE, skip=2, check.names = FALSE)
## create a compensation object 
comp &lt;- compensation(comp.mat)
#compensate GatingSet
gs &lt;- compensate(gs, comp)</code></pre>
<p><span style="color:red"><strong>New</strong>: You can now pass a list of <code>compensation</code> objects with elements named by <code>sampleNames(gs)</code> to achieve sample-specific compensations. e.g. </span></p>
<pre class="r"><code>gs &lt;- compensate(gs, comp.list)</code></pre>
<p>Then we can transform it with any transformation defined by the user through <code>trans_new</code> function of <code>scales</code> package.</p>
<pre class="r"><code>require(scales)
trans.func &lt;- asinh
inv.func &lt;- sinh
trans.obj &lt;- trans_new(&quot;myAsinh&quot;, trans.func, inv.func)</code></pre>
<p>The <code>inverse</code> transformation is required so that the gates and data can be visualized in <code>transformed</code> scale while the axis label still remains in the raw scale. Optionally, the <code>breaks</code> and <code>format</code> functions can be supplied to further customize the appearance of axis labels.</p>
<p>Besides doing all these by hand, we also provide some buildin transformations: <code>asinhtGml2_trans</code>, <code>flowjo_biexp_trans</code>, <code>flowjo_fasinh_trans</code> and <code>logicle_trans</code>. These are all very commonly used transformations in flow data analysis. User can construct the transform object by simply one-line of code. e.g.</p>
<pre class="r"><code>trans.obj &lt;- asinhtGml2_trans()
trans.obj</code></pre>
<pre><code>## Transformer:  asinhtGml2</code></pre>
<p>Once a <code>transformer</code> object is created, we must convert it to <code>transformerList</code> for <code>GatingSet</code> to use.</p>
<pre class="r"><code>chnls &lt;- colnames(fs)[3:6] 
transList &lt;- transformerList(chnls, trans.obj)</code></pre>
<p>Alternatively, the overloaded <code>estimateLogicle</code> method can be used directly on <code>GatingHierarchy</code> to generate a <code>transformerList</code> object automatically.</p>
<pre class="r"><code>estimateLogicle(gs[[1]], chnls)</code></pre>
<pre><code>## $`FL1-H`
## Transformer:  logicle 
## 
## $`FL2-H`
## Transformer:  logicle 
## 
## $`FL3-H`
## Transformer:  logicle 
## 
## $`FL2-A`
## Transformer:  logicle 
## 
## attr(,&quot;class&quot;)
## [1] &quot;transformerList&quot; &quot;list&quot;</code></pre>
<p>Now we can transform our <code>GatingSet</code> with this <code>transformerList</code> object. It will also store the transformation in the <code>GatingSet</code> and can be used to inverse-transform the data.</p>
<pre class="r"><code>gs &lt;- transform(gs, transList)
gs_get_pop_paths(gs) </code></pre>
<pre><code>## [1] &quot;root&quot;</code></pre>
<p>It now only contains the root node. We can add our first <code>rectangleGate</code>:</p>
<pre class="r"><code>rg &lt;- rectangleGate(&quot;FSC-H&quot;=c(200,400), &quot;SSC-H&quot;=c(250, 400), filterId=&quot;rectangle&quot;)
nodeID &lt;- gs_pop_add(gs, rg)
nodeID</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>gs_get_pop_paths(gs)  </code></pre>
<pre><code>## [1] &quot;root&quot;       &quot;/rectangle&quot;</code></pre>
<p>Note that the gate is added to the root node by default if the parent is not specified.
Then we add a <code>quadGate</code> to the new population generated by the <code>rectangleGate</code> which is named after the <code>filterId</code> of the gate because the name was not specified when the <code>add</code> method was called.</p>
<pre class="r"><code>qg &lt;- quadGate(&quot;FL1-H&quot;= 0.2, &quot;FL2-H&quot;= 0.4)
nodeIDs &lt;- gs_pop_add(gs,qg,parent=&quot;rectangle&quot;)
nodeIDs </code></pre>
<pre><code>## [1] 3 4 5 6</code></pre>
<pre class="r"><code>gs_get_pop_paths(gs)</code></pre>
<pre><code>## [1] &quot;root&quot;                          &quot;/rectangle&quot;                   
## [3] &quot;/rectangle/CD15 FITC-CD45 PE+&quot; &quot;/rectangle/CD15 FITC+CD45 PE+&quot;
## [5] &quot;/rectangle/CD15 FITC+CD45 PE-&quot; &quot;/rectangle/CD15 FITC-CD45 PE-&quot;</code></pre>
<p>Here <code>quadGate</code> produces four population nodes/populations named after the dimensions of the gate if names are not specified.</p>
<p>A Boolean gate can also be defined and added to GatingSet:</p>
<pre class="r"><code>bg &lt;- booleanFilter(`CD15 FITC-CD45 PE+|CD15 FITC+CD45 PE-`)
bg</code></pre>
<pre><code>## booleanFilter filter &#39;CD15 FITC-CD45 PE+|CD15 FITC+CD45 PE-&#39; evaluating the expression:
## CD15 FITC-CD45 PE+|CD15 FITC+CD45 PE-</code></pre>
<pre class="r"><code>nodeID2 &lt;- gs_pop_add(gs,bg,parent=&quot;rectangle&quot;)
nodeID2</code></pre>
<pre><code>## [1] 7</code></pre>
<pre class="r"><code>gs_get_pop_paths(gs)</code></pre>
<pre><code>## [1] &quot;root&quot;                                            
## [2] &quot;/rectangle&quot;                                      
## [3] &quot;/rectangle/CD15 FITC-CD45 PE+&quot;                   
## [4] &quot;/rectangle/CD15 FITC+CD45 PE+&quot;                   
## [5] &quot;/rectangle/CD15 FITC+CD45 PE-&quot;                   
## [6] &quot;/rectangle/CD15 FITC-CD45 PE-&quot;                   
## [7] &quot;/rectangle/CD15 FITC-CD45 PE+|CD15 FITC+CD45 PE-&quot;</code></pre>
<p>The gating hierarchy is plotted by:</p>
<pre class="r"><code>plot(gs, bool=TRUE)</code></pre>
<p><img src="docs/examples/flowWorkspace/flowWorkspace-Introduction_files/figure-html/plot-gh-1.png" width="672" />
Note that Boolean gate is skipped by default and thus needs to be enabled explictily.</p>
<p>Now all the gates are added to the gating tree but the actual data is not gated yet.
This is done by calling the <code>recompute</code> method explictily:</p>
<pre class="r"><code>recompute(gs)</code></pre>
<p>After gating is finished, gating results can be visualized by the <code>autoplot</code> method:</p>
<pre class="r"><code>autoplot(gs,&quot;rectangle&quot;) #plot one Gate</code></pre>
<p><img src="docs/examples/flowWorkspace/flowWorkspace-Introduction_files/figure-html/autoplot-rect-1.png" width="672" />
Multiple gates can be plotted on the same panel:</p>
<pre class="r"><code>autoplot(gs, gs_pop_get_children(gs[[1]], &quot;rectangle&quot;)[1:4])</code></pre>
<p><img src="docs/examples/flowWorkspace/flowWorkspace-Introduction_files/figure-html/autoplot-multiple-1.png" width="672" />
We may also want to plot all the gates without specifying the gate index:</p>
<pre class="r"><code>autoplot(gs[[1]])</code></pre>
<p><img src="docs/examples/flowWorkspace/flowWorkspace-Introduction_files/figure-html/autoplot-gh-bool-1.png" width="672" /></p>
<p>We can retrieve all the compensation matrices from the <code>GatingHierarchy</code> in case we wish to use the compensation or transformation for the new data,</p>
<pre class="r"><code>gh &lt;- gs[[1]]
gh_get_compensations(gh);</code></pre>
<pre><code>## Compensation object &#39;defaultCompensation&#39;:
##          FL1-H    FL2-H   FL3-H   FL4-H
## FL1-H 1.000000 0.240000 0.03200 0.00113
## FL2-H 0.007770 1.000000 0.14000 0.00274
## FL3-H 0.008690 0.170000 1.00000 0.21000
## FL4-H 0.000795 0.000995 0.00323 1.00000</code></pre>
<p>Or we can retrieve transformations:</p>
<pre class="r"><code>trans &lt;- gh_get_transformations(gh)
names(trans)</code></pre>
<pre><code>## [1] &quot;FL1-H&quot; &quot;FL2-A&quot; &quot;FL2-H&quot; &quot;FL3-H&quot;</code></pre>
<pre class="r"><code>trans[[1]]</code></pre>
<pre><code>## function(x){ #copied fom c++ code
##     length * ((asinh(x * sinh(m * log(10)) / t) + a * log(10)) / ((m + a) * log(10)))
##   }
## &lt;bytecode: 0x5609396dc7c0&gt;
## &lt;environment: 0x560940766038&gt;
## attr(,&quot;type&quot;)
## [1] &quot;fasinh&quot;</code></pre>
<p>If we want to remove one node, simply:</p>
<pre class="r"><code>Rm(&#39;rectangle&#39;, gs)</code></pre>
<pre><code>## Warning: &#39;Rm&#39; is deprecated.
## Use &#39;gs_pop_remove&#39; instead.
## See help(&quot;Deprecated&quot;)</code></pre>
<pre class="r"><code>gs_get_pop_paths(gs)</code></pre>
<pre><code>## [1] &quot;root&quot;</code></pre>
<p>As we see, removing one node causes all its descendants to be removed as well.</p>
<div id="archive-and-clone" class="section level3">
<h3>Archive and Clone</h3>
<p>Oftentimes, we need to save a <code>GatingSet</code> including the gated flow data, gates, and populations to disk and reload it later on. This can be done by:</p>
<pre class="r"><code>tmp &lt;- tempdir()
save_gs(gs,path = file.path(tmp,&quot;my_gs&quot;))
gs &lt;- load_gs(file.path(tmp,&quot;my_gs&quot;))</code></pre>
<p>We also provide the <code>gs_clone</code> method to make a full copy of an existing <code>GatingSet</code>:</p>
<pre class="r"><code>gs1 &lt;- gs_clone(gs)</code></pre>
<p>To only copy the gates and populations without copy the underlying cyto data.</p>
<pre class="r"><code>gs2 &lt;- gs_copy_tree_only(gs)</code></pre>
<p>This is a lightweight copying which is faster than <code>gs_clone</code>. But be aware the new <code>GatingSet</code> share the same events data (i.e. <code>gs_cyto_data(gs)</code>) with the original one.</p>
<p>Note that the <code>GatingSet</code> is a purely reference class with an external pointer that points to the internal ‘C’ data structure. So make sure to use these methods in order to save or make a copy of an existing <code>GatingSet</code> object. The regular R assignment (&lt;-) or <code>save</code> routine doesn’t work as expected for <code>GatingSet</code> objects.</p>
</div>
</div>
<div id="the-cytoframe-and-cytoset-classes" class="section level2">
<h2>The cytoframe and cytoset classes</h2>
<p>The <code>GatingSet</code> class no longer uses <code>flowFrame</code> and <code>flowSet</code> objects for containing the underlying flow data, but rather now uses the analogous <code>cytoframe</code> and <code>cytoset</code> classes. <code>cytoframe</code> and <code>cytoset</code> are essentially reference classes with pointers to internal ‘C’ data structures and thus enable <code>GatingSet</code> operations to be performed more efficiently.</p>
<p>While working with <code>GatingSet</code> objects will often entail working with <code>cytoframe</code> and <code>cytoset</code> objects implicitly, it is also possible to directly work with objects of both of these classes.</p>
<div id="reading-a-cytoframe" class="section level3">
<h3>Reading a <code>cytoframe</code></h3>
<p>Instead of <code>read.FCS()</code>, <code>cytoframe</code> objects can be created from FCS files with the <code>load_cytoframe_from_fcs()</code> method. The optional <code>num_threads</code> argument allows for parallelization of the read operation.</p>
<pre class="r"><code>files &lt;- list.files(dataDir, &quot;Cyto&quot;, full.names = TRUE)
cf &lt;- load_cytoframe_from_fcs(files[1], num_threads = 4)
cf</code></pre>
<pre><code>## cytoframe object &#39;CytoTrol_CytoTrol_1.fcs&#39;
## with 119531 cells and 12 observables:
##             name         desc     range  minRange  maxRange
## $P1        FSC-A           NA    262143         0    262143
## $P2        FSC-H           NA    262143         0    262143
## $P3        FSC-W           NA    262143         0    262143
## $P4        SSC-A           NA    262143         0    262143
## $P5       B710-A  CD4 PcpCy55    262143      -111    262143
## ...          ...          ...       ...       ...       ...
## $P8       V450-A     CD3 V450    262143      -111    262143
## $P9       V545-A  HLA-DR V500    262143      -111    262143
## $P10      G560-A      CCR7 PE    262143      -111    262143
## $P11      G780-A CD45RA PECy7    262143      -111    262143
## $P12        Time           NA    262143         0    262143
## 199 keywords are stored in the &#39;description&#39; slot</code></pre>
<p>Instead of using <code>read.FCSheader()</code> to obtain only the header of the file, just use the <code>text.only</code> argument to <code>load_cytoframe_from_fcs()</code>.</p>
<pre class="r"><code>cfh &lt;- load_cytoframe_from_fcs(files[1], text.only = TRUE)</code></pre>
<pre><code>## Warning in parseFCS(normalizePath(filename), list(which.lines = which.lines, :
## text_only is ignored when format is set to &#39;h5&#39; or &#39;tile&#39;!</code></pre>
<pre class="r"><code>cfh</code></pre>
<pre><code>## cytoframe object &#39;CytoTrol_CytoTrol_1.fcs&#39;
## with 119531 cells and 12 observables:
##             name         desc     range  minRange  maxRange
## $P1        FSC-A           NA    262143         0    262143
## $P2        FSC-H           NA    262143         0    262143
## $P3        FSC-W           NA    262143         0    262143
## $P4        SSC-A           NA    262143         0    262143
## $P5       B710-A  CD4 PcpCy55    262143      -111    262143
## ...          ...          ...       ...       ...       ...
## $P8       V450-A     CD3 V450    262143      -111    262143
## $P9       V545-A  HLA-DR V500    262143      -111    262143
## $P10      G560-A      CCR7 PE    262143      -111    262143
## $P11      G780-A CD45RA PECy7    262143      -111    262143
## $P12        Time           NA    262143         0    262143
## 199 keywords are stored in the &#39;description&#39; slot</code></pre>
</div>
<div id="cytoframe-accessors" class="section level3">
<h3><code>cytoframe</code> Accessors</h3>
<p>The accessor methods function the same as they would for a <code>flowFrame</code></p>
<pre class="r"><code>dim(cf)</code></pre>
<pre><code>##     events parameters 
##     119531         12</code></pre>
<pre class="r"><code>colnames(cf)</code></pre>
<pre><code>##  [1] &quot;FSC-A&quot;  &quot;FSC-H&quot;  &quot;FSC-W&quot;  &quot;SSC-A&quot;  &quot;B710-A&quot; &quot;R660-A&quot; &quot;R780-A&quot; &quot;V450-A&quot;
##  [9] &quot;V545-A&quot; &quot;G560-A&quot; &quot;G780-A&quot; &quot;Time&quot;</code></pre>
<pre class="r"><code>head(exprs(cf))</code></pre>
<pre><code>##          FSC-A  FSC-H    FSC-W     SSC-A   B710-A   R660-A    R780-A    V450-A
## [1,] 140733.05 133376 69150.98  91113.96 22311.24 35576.07  14302.16 16232.649
## [2,]  26195.32  26207 65506.79  10115.28     5.04   447.93    682.56    43.700
## [3,]  64294.02  51594 81667.89 174620.03   371.28   851.62    -66.36   335.350
## [4,] 128393.87 103613 81210.08 150625.44  1494.36  5672.20   2979.09  1492.450
## [5,] 127717.88 119616 69974.92  76954.91  2545.20  2272.83 124635.93  8608.899
## [6,] 134347.02 125651 70071.60  70116.48 23052.96  1758.54   5281.15  4849.750
##        V545-A   G560-A   G780-A Time
## [1,]  7644.65  4113.60 12672.00  0.2
## [2,]    77.90   -91.20    18.24  0.4
## [3,]   971.85   273.60   271.68  0.6
## [4,] 28790.70   771.84   988.80  0.6
## [5,]  4190.45 14306.88 58977.60  0.7
## [6,]  2859.50  2249.28  1560.96  0.7</code></pre>
<pre class="r"><code>spillover(cf)</code></pre>
<pre><code>## $SPILL
##              B710-A       R660-A       R780-A       V450-A      V545-A
## B710-A 1.000000e+00 3.143890e-02 0.1909655363 3.057568e-03 0.002047231
## R660-A 5.537983e-03 1.000000e+00 0.1768123886 0.000000e+00 0.000000000
## R780-A 9.958625e-05 9.847661e-03 1.0000000000 0.000000e+00 0.000000000
## V450-A 0.000000e+00 8.909845e-05 0.0000000000 1.000000e+00 0.451194675
## V545-A 2.477092e-03 5.235156e-04 0.0000000000 3.796154e-02 1.000000000
## G560-A 1.172236e-01 1.642721e-03 0.0003321532 0.000000e+00 0.000000000
## G780-A 1.420516e-02 4.568956e-04 0.1754022374 8.902497e-05 0.000000000
##              G560-A      G780-A
## B710-A 3.442413e-04 0.071933810
## R660-A 0.000000e+00 0.006618897
## R780-A 0.000000e+00 0.035399709
## V450-A 1.082746e-04 0.000000000
## V545-A 6.361807e-05 0.000000000
## G560-A 1.000000e+00 0.009219359
## G780-A 4.096870e-02 1.000000000
## 
## $spillover
## NULL
## 
## $`$SPILLOVER`
## NULL</code></pre>
<pre class="r"><code>head(keyword(cf))</code></pre>
<pre><code>## $FCSversion
## [1] &quot;3&quot;
## 
## $`$BEGINANALYSIS`
## [1] &quot;0&quot;
## 
## $`$ENDANALYSIS`
## [1] &quot;0&quot;
## 
## $`$BEGINSTEXT`
## [1] &quot;0&quot;
## 
## $`$ENDSTEXT`
## [1] &quot;0&quot;
## 
## $`$BEGINDATA`
## [1] &quot;3264&quot;</code></pre>
</div>
<div id="pass-by-reference" class="section level3">
<h3>Pass By Reference</h3>
<p>As <code>cytoframe</code> and <code>cytoset</code> are reference classes, copying objects of either class by the assignment operator (<code>&lt;-</code>) will simply provide a copy of the external pointer and so changes made to the copy will also affect the original object.</p>
<pre class="r"><code>cf1 &lt;- cf # cf is a reference
colnames(cf1)[1]</code></pre>
<pre><code>## [1] &quot;FSC-A&quot;</code></pre>
<pre class="r"><code>colnames(cf1)[1] &lt;- &quot;t&quot;
colnames(cf)[1] # The change affects the original cf object</code></pre>
<pre><code>## [1] &quot;t&quot;</code></pre>
</div>
<div id="views" class="section level3">
<h3>Views</h3>
<p>Extracting a subset of a <code>cytoframe</code> is not computationally intensive, as it merely constructs a view of the data of the original <code>cytoframe</code>. However, both objects still share the same underlying pointer to all of the data and thus changes to a view will affect the data of the original <code>cytoframe</code>.</p>
<pre class="r"><code>cf1 &lt;- cf[1:10, 2:3]
dim(cf1)</code></pre>
<pre><code>##     events parameters 
##         10          2</code></pre>
<pre class="r"><code>exprs(cf)[2,3]</code></pre>
<pre><code>##    FSC-W 
## 65506.79</code></pre>
<pre class="r"><code>exprs(cf1)[2,2] &lt;- 0 # data change affects the orignal cf
exprs(cf)[2,3]</code></pre>
<pre><code>## FSC-W 
##     0</code></pre>
<p>To construct a new view of an entire <code>cytoframe</code>, use the <code>[]</code> method rather than the <code>&lt;-</code> operator. This will ensure that a new view is created to the full underlying dataset.</p>
<pre class="r"><code>cf1 &lt;- cf[]</code></pre>
</div>
<div id="deep-copy" class="section level3">
<h3>Deep Copy</h3>
<p>It is also possible to perform a deep copy of a <code>cytoframe</code> or a view of it, resulting in two objects pointing to distinct C-level representations of the data. This is accomplished with the <code>realize_view</code> method.</p>
<pre class="r"><code>cf &lt;- load_cytoframe_from_fcs(files[1], num_threads = 4) # starting fresh
cf1 &lt;- realize_view(cf[1:10, 2:3])
dim(cf1)</code></pre>
<pre><code>##     events parameters 
##         10          2</code></pre>
<pre class="r"><code>exprs(cf)[2,3]</code></pre>
<pre><code>##    FSC-W 
## 65506.79</code></pre>
<pre class="r"><code>exprs(cf1)[2,2] &lt;- 0 # data change no longer affects the original cf
exprs(cf)[2,3]</code></pre>
<pre><code>##    FSC-W 
## 65506.79</code></pre>
<pre class="r"><code>exprs(cf1)[2,2] # but does affect the separate data of cf1</code></pre>
<pre><code>## FSC-W 
##     0</code></pre>
<p>Similarly, if a deep copy of all of the data is desired (not a subset), simply call <code>realize_view</code> on the original <code>cytoframe</code>.</p>
</div>
<div id="interconversion-between-cytoframe-and-flowframe" class="section level3">
<h3>Interconversion between <code>cytoframe</code> and <code>flowFrame</code></h3>
<p>Conversion of objects between the <code>cytoframe</code> and <code>flowFrame</code> classes is accomplished with a few coercion methods</p>
<pre class="r"><code>fr &lt;- cytoframe_to_flowFrame(cf)
class(fr)</code></pre>
<pre><code>## [1] &quot;flowFrame&quot;
## attr(,&quot;package&quot;)
## [1] &quot;flowCore&quot;</code></pre>
<pre class="r"><code>cf_back &lt;- flowFrame_to_cytoframe(fr)
class(cf_back)</code></pre>
<pre><code>## [1] &quot;cytoframe&quot;
## attr(,&quot;package&quot;)
## [1] &quot;flowWorkspace&quot;</code></pre>
<p>Of course (as a side note), here <code>flowFrame_to_cytoframe()</code> had no knowledge of the <code>cytoframe</code> origin of <code>fr</code>, so <code>cf_back</code> points to a new copy of the underlying data.</p>
<pre class="r"><code>identical(cf@pointer, cf_back@pointer) # These point to distinct copies of the data</code></pre>
<pre><code>## [1] FALSE</code></pre>
</div>
<div id="savingloading-a-cytoframe-in-h5" class="section level3">
<h3>Saving/Loading a <code>cytoframe</code> in h5</h3>
<p>A couple of methods handle the task of writing or reading a <code>cytoframe</code> in the HDF5 format on disk</p>
<pre class="r"><code>tmpfile &lt;- tempfile(fileext = &quot;.h5&quot;)
cf_write_h5(cf, tmpfile)
loaded &lt;- load_cytoframe(tmpfile)</code></pre>
</div>
<div id="cytoset-methods" class="section level3">
<h3><code>cytoset</code> methods</h3>
<p>Most of the above methods for <code>cytoframe</code> objects have <code>cytoset</code> analogs.</p>
<p>For reading in a <code>cytoset</code> from FCS files, use <code>load_cytoset_from_fcs</code></p>
<pre class="r"><code>files &lt;- list.files(dataDir, &quot;Cyto&quot;, full.names = TRUE)
cs &lt;- load_cytoset_from_fcs(files, num_threads = 4)
cs</code></pre>
<pre><code>## A cytoset with 2 samples.
## 
##   column names:
##     FSC-A, FSC-H, FSC-W, SSC-A, B710-A, R660-A, R780-A, V450-A, V545-A, G560-A, G780-A, Time</code></pre>
<p>Once constructed, it can be saved/loaded through more efficient archive format.</p>
<pre class="r"><code>tmp &lt;- tempfile()
save_cytoset(cs, tmp)
cs &lt;- load_cytoset(tmp, backend_readonly = FALSE)</code></pre>
<p>note that <code>backend_readonly</code> is set to <code>TRUE</code> by default to protect the data from accidental changes. So it has to be turned off explicitly if your want to modify the loaded <code>cs</code></p>
<p>The accessor methods function the same as they would for a <code>flowSet</code></p>
<pre class="r"><code>colnames(cs)</code></pre>
<pre><code>##  [1] &quot;FSC-A&quot;  &quot;FSC-H&quot;  &quot;FSC-W&quot;  &quot;SSC-A&quot;  &quot;B710-A&quot; &quot;R660-A&quot; &quot;R780-A&quot; &quot;V450-A&quot;
##  [9] &quot;V545-A&quot; &quot;G560-A&quot; &quot;G780-A&quot; &quot;Time&quot;</code></pre>
<p>Subsetting using <code>[</code> will work in a manner similar to that for a <code>flowSet</code>, but will result in another <code>cytoset</code> that is a view in to the data of the original <code>cytoset</code>. The <code>Subset()</code> method, when called on a <code>cytoset</code>, will also return a <code>cytoset</code> that is a view in to the orignal data rather than a deep copy.</p>
<pre class="r"><code>sub_cs &lt;- cs[1]</code></pre>
<p><strong>Important:</strong> xtraction using <code>[[</code> on a <code>cytoset</code> will by default return a <code>cytoframe</code> and so will represent a reference of the underlying data. Thus, altering the result of the extraction <strong>will</strong> alter the underlying data of the original <code>cytoset</code>.</p>
<pre class="r"><code>sub_fr &lt;- cs[[1]]
exprs(cs[[1]])[2,2]</code></pre>
<pre><code>## FSC-H 
## 26207</code></pre>
<pre class="r"><code>exprs(sub_fr)[2,2] &lt;- 0 # This WILL affect the original data
exprs(cs[[1]])[2,2]</code></pre>
<pre><code>## FSC-H 
##     0</code></pre>
<p>To return a <code>flowFrame</code> that represents a copy of the data of the <code>original</code> cytoset, you need to use the <code>returnType</code> argument.</p>
<pre class="r"><code>sub_cf &lt;- cs[[1, returnType = &quot;flowFrame&quot;]]
exprs(cs[[1]])[2,2]</code></pre>
<pre><code>## FSC-H 
##     0</code></pre>
<pre class="r"><code>exprs(sub_cf)[2,2] &lt;- 100 # This WILL NOT affect the original data
exprs(cs[[1]])[2,2]</code></pre>
<pre><code>## FSC-H 
##     0</code></pre>
<p>Alternatively, if it is easier to remember, <code>get_cytoframe_from_cs</code> will accomplish the same goal</p>
<pre class="r"><code>sub_cf &lt;- get_cytoframe_from_cs(cs,1)</code></pre>
<p>Finally, the <code>[]</code> and <code>realize_view()</code> methods work in a similar manner for <code>cytoset</code> objects as <code>cytoframe</code> objects. <code>[]</code> will return a view in to the original data while <code>realize_view()</code> will perform a deep copy.</p>
</div>
</div>
<div id="troubleshooting-and-error-reporting" class="section level2">
<h2>Troubleshooting and error reporting</h2>
<p>If this package is throwing errors when parsing your workspace, contact the package author by emails for post an issue on <a href="https://github.com/RGLab/flowWorkspace/issues" class="uri">https://github.com/RGLab/flowWorkspace/issues</a>. If you can send your workspace by email, we can test, debug, and fix the package so that it works for you. Our goal is to provide a tool that works, and that people find useful.</p>
</div>
